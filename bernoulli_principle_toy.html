<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¼¯åŠªåˆ©åŸç†ç§‘å­¦ç©å…·</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 100;
            max-width: 300px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            color: #333;
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.5);
        }
        
        .value-display {
            color: #667eea;
            font-weight: bold;
            font-size: 12px;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            max-width: 350px;
            font-size: 14px;
            z-index: 100;
            transition: all 0.3s ease;
        }
        
        .info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }
        
        .toggle-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease;
        }
        
        .toggle-btn:hover {
            background: #5a67d8;
        }
        
        .toggle-btn.collapsed {
            transform: rotate(180deg);
        }
        
        .info-content {
            max-height: 300px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }
        
        .info-content.collapsed {
            max-height: 0;
            opacity: 0;
        }
        
        .equation {
            background: #f0f4f8;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
            border-left: 4px solid #667eea;
        }
        
        .highlight {
            color: #667eea;
            font-weight: bold;
        }
        
        .drag-hint {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            font-size: 12px;
            color: #667eea;
            z-index: 100;
        }
        
        .wind-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
        }
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="controls">
            <h3 style="margin-top: 0; color: #333;">ä¼¯åŠªåˆ©åŸç†æ§åˆ¶å°</h3>
            
            <div class="control-group">
                <label for="windSpeed">é¢¨é€Ÿ (m/s)</label>
                <input type="range" id="windSpeed" min="0" max="50" value="20">
                <div class="value-display">ç•¶å‰: <span id="windSpeedValue">20</span> m/s</div>
            </div>
            
            <div class="control-group">
                <label for="ballSize">çƒé«”å¤§å°</label>
                <input type="range" id="ballSize" min="0.5" max="3" step="0.1" value="1">
                <div class="value-display">åŠå¾‘: <span id="ballSizeValue">1.0</span></div>
            </div>
            
            <div class="control-group">
                <label for="ballMass">çƒé«”è³ªé‡</label>
                <input type="range" id="ballMass" min="0.1" max="2" step="0.1" value="0.5">
                <div class="value-display">è³ªé‡: <span id="ballMassValue">0.5</span> kg</div>
            </div>
            
            <div class="control-group">
                <label for="windDirection">é¢¨å‘è§’åº¦</label>
                <input type="range" id="windDirection" min="0" max="360" value="0">
                <div class="value-display">è§’åº¦: <span id="windDirectionValue">0</span>Â°</div>
            </div>
            
            <div class="control-group">
                <label for="windVertical">å‚ç›´é¢¨åŠ›</label>
                <input type="range" id="windVertical" min="-20" max="20" value="0">
                <div class="value-display">å‚ç›´: <span id="windVerticalValue">0</span> m/s</div>
            </div>
        </div>
        
        <div class="drag-hint">
            ğŸ–±ï¸ æ‹–æ‹½çƒé«”ç§»å‹•ä½ç½®<br>
            ğŸŒªï¸ èª¿æ•´é¢¨å‘é«”é©—ä¸åŒæ•ˆæœ
        </div>
        
        <div class="pressure-indicator">
            <h4 style="margin-top: 0;">å£“åŠ›å·®æ¸¬é‡</h4>
            <div>ä¸Šæ–¹å£“åŠ›: <span class="highlight" id="topPressure">101.3</span> kPa</div>
            <div>ä¸‹æ–¹å£“åŠ›: <span class="highlight" id="bottomPressure">101.3</span> kPa</div>
            <div>å£“åŠ›å·®: <span class="highlight" id="pressureDiff">0.0</span> kPa</div>
            <div>å‡åŠ›: <span class="highlight" id="liftForce">0.0</span> N</div>
        </div>
        
        <div id="info">
            <div class="info-header" id="infoHeader">
                <h4 style="margin: 0;">ä¼¯åŠªåˆ©åŸç†</h4>
                <button class="toggle-btn" id="toggleBtn">â–¼</button>
            </div>
            <div class="info-content" id="infoContent">
                <p>ç•¶ç©ºæ°£æµéçƒé«”æ™‚ï¼Œä¸Šæ–¹æµé€Ÿè¼ƒå¿«ï¼Œä¸‹æ–¹æµé€Ÿè¼ƒæ…¢</p>
                <div class="equation">
                    P + Â½ÏvÂ² + Ïgh = å¸¸æ•¸
                </div>
                <p><strong>åŸç†ï¼š</strong>æµé€Ÿè¶Šå¿«ï¼Œå£“åŠ›è¶Šå°ã€‚ä¸Šä¸‹å£“åŠ›å·®ç”¢ç”Ÿå‡åŠ›ï¼</p>
                <p><strong>å…¬å¼èªªæ˜ï¼š</strong></p>
                <ul style="margin: 5px 0; padding-left: 20px; font-size: 12px;">
                    <li><strong>P</strong> = æµé«”å£“åŠ›</li>
                    <li><strong>Ï</strong> = æµé«”å¯†åº¦ (ç©ºæ°£: 1.225 kg/mÂ³)</li>
                    <li><strong>v</strong> = æµé«”é€Ÿåº¦</li>
                    <li><strong>g</strong> = é‡åŠ›åŠ é€Ÿåº¦ (9.81 m/sÂ²)</li>
                    <li><strong>h</strong> = é«˜åº¦</li>
                </ul>
                <p><strong>æ“ä½œï¼š</strong>èª¿æ•´é¢¨é€Ÿè§€å¯Ÿçƒé«”çš„æµ®åŠ›è®ŠåŒ–</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // æŠ˜ç–ŠåŠŸèƒ½
        function toggleInfo() {
            const content = document.getElementById('infoContent');
            const btn = document.getElementById('toggleBtn');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                btn.classList.remove('collapsed');
                btn.textContent = 'â–¼';
            } else {
                content.classList.add('collapsed');
                btn.classList.add('collapsed');
                btn.textContent = 'â–²';
            }
        }
        
        // äº‹ä»¶ç›£è½å™¨
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('infoHeader').addEventListener('click', toggleInfo);
        });
        
        // å ´æ™¯è¨­ç½®
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB, 1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // å…‰ç…§
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // çƒé«”ï¼ˆæ¼”ç¤ºå°è±¡ï¼‰
        let ballGeometry = new THREE.SphereGeometry(1, 32, 32);
        const ballMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff6b6b,
            shininess: 100,
            transparent: true,
            opacity: 0.9
        });
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(0, 0, 0);
        ball.castShadow = true;
        scene.add(ball);
        
        // é¢¨å ´å¯è¦–åŒ–ç²’å­
        const particleCount = 1000;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 30 - 15;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
            
            velocities[i * 3] = 0;
            velocities[i * 3 + 1] = 0;
            velocities[i * 3 + 2] = 0;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 0.7
        });
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        
        // åœ°é¢
        const groundGeometry = new THREE.PlaneGeometry(50, 30);
        const groundMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x90EE90,
            transparent: true,
            opacity: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -8;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // æ§åˆ¶è®Šæ•¸
        let windSpeed = 20;
        let windDirection = 0; // åº¦æ•¸
        let windVertical = 0;  // å‚ç›´é¢¨é€Ÿ
        let ballRadius = 1;
        let ballMass = 0.5;
        let ballVelocityY = 0;
        let ballVelocityX = 0;
        let ballVelocityZ = 0;
        let gravity = -9.81;
        
        // æ‹–æ‹½ç›¸é—œè®Šæ•¸
        let isDragging = false;
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        
        // ç‰©ç†å¸¸æ•¸
        const airDensity = 1.225; // kg/mÂ³
        const atmosphericPressure = 101325; // Pa
        
        // æ§åˆ¶äº‹ä»¶
        const windSpeedSlider = document.getElementById('windSpeed');
        const windDirectionSlider = document.getElementById('windDirection');
        const windVerticalSlider = document.getElementById('windVertical');
        const ballSizeSlider = document.getElementById('ballSize');
        const ballMassSlider = document.getElementById('ballMass');
        
        windSpeedSlider.addEventListener('input', (e) => {
            windSpeed = parseFloat(e.target.value);
            document.getElementById('windSpeedValue').textContent = windSpeed;
        });
        
        windDirectionSlider.addEventListener('input', (e) => {
            windDirection = parseFloat(e.target.value);
            document.getElementById('windDirectionValue').textContent = windDirection;
        });
        
        windVerticalSlider.addEventListener('input', (e) => {
            windVertical = parseFloat(e.target.value);
            document.getElementById('windVerticalValue').textContent = windVertical;
        });
        
        ballSizeSlider.addEventListener('input', (e) => {
            ballRadius = parseFloat(e.target.value);
            document.getElementById('ballSizeValue').textContent = ballRadius.toFixed(1);
            
            // æ›´æ–°çƒé«”å¹¾ä½•
            scene.remove(ball);
            ballGeometry.dispose();
            ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const newBall = new THREE.Mesh(ballGeometry, ballMaterial);
            newBall.position.copy(ball.position);
            newBall.castShadow = true;
            scene.add(newBall);
            ball.geometry = ballGeometry;
            ball.copy(newBall);
            scene.remove(newBall);
            scene.add(ball);
        });
        
        ballMassSlider.addEventListener('input', (e) => {
            ballMass = parseFloat(e.target.value);
            document.getElementById('ballMassValue').textContent = ballMass.toFixed(1);
        });
        
        // æ»‘é¼ äº‹ä»¶è™•ç†
        function onMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ball);
            
            if (intersects.length > 0) {
                isDragging = true;
                renderer.domElement.style.cursor = 'grabbing';
            }
        }
        
        function onMouseMove(event) {
            if (!isDragging) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(dragPlane, intersectPoint);
            
            // é™åˆ¶æ‹–æ‹½ç¯„åœ
            intersectPoint.x = Math.max(-10, Math.min(10, intersectPoint.x));
            intersectPoint.y = Math.max(-6, Math.min(6, intersectPoint.y));
            intersectPoint.z = Math.max(-5, Math.min(5, intersectPoint.z));
            
            ball.position.copy(intersectPoint);
            
            // é‡ç½®é€Ÿåº¦
            ballVelocityX = 0;
            ballVelocityY = 0;
            ballVelocityZ = 0;
        }
        
        function onMouseUp(event) {
            isDragging = false;
            renderer.domElement.style.cursor = 'default';
        }
        
        // æ·»åŠ æ»‘é¼ äº‹ä»¶ç›£è½å™¨
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        
        // è¨ˆç®—ä¼¯åŠªåˆ©æ•ˆæ‡‰
        function calculateBernoulliEffect() {
            // å°‡é¢¨å‘è½‰æ›ç‚ºå‘é‡
            const windRad = (windDirection * Math.PI) / 180;
            const windX = windSpeed * Math.cos(windRad);
            const windZ = windSpeed * Math.sin(windRad);
            const windY = windVertical;
            
            // è¨ˆç®—ç›¸å°æ–¼çƒé«”çš„é¢¨é€Ÿ
            const relativeWindSpeed = Math.sqrt(windX * windX + windY * windY + windZ * windZ);
            
            // çƒé«”å‘¨åœçš„æµé€Ÿåˆ†å¸ƒï¼ˆç°¡åŒ–æ¨¡å‹ï¼‰
            const topVelocity = relativeWindSpeed * 1.5; // ä¸Šæ–¹æµé€Ÿè¼ƒå¿«
            const bottomVelocity = relativeWindSpeed * 0.7; // ä¸‹æ–¹æµé€Ÿè¼ƒæ…¢
            
            // æ ¹æ“šä¼¯åŠªåˆ©æ–¹ç¨‹è¨ˆç®—å£“åŠ›
            const topPressure = atmosphericPressure - 0.5 * airDensity * topVelocity * topVelocity;
            const bottomPressure = atmosphericPressure - 0.5 * airDensity * bottomVelocity * bottomVelocity;
            
            const pressureDifference = bottomPressure - topPressure;
            const ballArea = Math.PI * ballRadius * ballRadius;
            const liftForce = pressureDifference * ballArea / 1000; // è½‰æ›ç‚ºN
            
            // è¨ˆç®—å´å‘åŠ›ï¼ˆåŸºæ–¼é¢¨å‘ï¼‰
            const sideForce = windX * airDensity * ballArea * 0.1;
            const frontForce = windZ * airDensity * ballArea * 0.1;
            
            // æ›´æ–°é¡¯ç¤º
            document.getElementById('topPressure').textContent = (topPressure / 1000).toFixed(1);
            document.getElementById('bottomPressure').textContent = (bottomPressure / 1000).toFixed(1);
            document.getElementById('pressureDiff').textContent = (pressureDifference / 1000).toFixed(2);
            document.getElementById('liftForce').textContent = liftForce.toFixed(2);
            
            return { lift: liftForce, side: sideForce, front: frontForce };
        }
        
        // æ›´æ–°ç²’å­æ¨¡æ“¬é¢¨å ´
        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            
            // é¢¨å‘å‘é‡
            const windRad = (windDirection * Math.PI) / 180;
            const windVecX = Math.cos(windRad);
            const windVecZ = Math.sin(windRad);
            
            for (let i = 0; i < particleCount; i++) {
                const idx = i * 3;
                let x = positions[idx];
                let y = positions[idx + 1];
                let z = positions[idx + 2];
                
                // è¨ˆç®—åˆ°çƒé«”çš„è·é›¢
                const dx = x - ball.position.x;
                const dy = y - ball.position.y;
                const dz = z - ball.position.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                // é¢¨å ´æµå‹•
                if (distance > ballRadius + 0.5) {
                    // é é›¢çƒé«”çš„ç²’å­æŒ‰é¢¨å‘æµå‹•
                    x += windVecX * windSpeed * 0.02;
                    z += windVecZ * windSpeed * 0.02;
                    y += windVertical * 0.02;
                    
                    // çƒé«”å‘¨åœçš„æµç·šå½æ›²
                    if (distance < ballRadius + 3) {
                        const influence = (ballRadius + 3 - distance) / 3;
                        y += (dy > 0 ? 1 : -1) * influence * windSpeed * 0.01;
                    }
                } else {
                    // ç¹éçƒé«”
                    const angle = Math.atan2(dy, dx);
                    x += Math.cos(angle + Math.PI/2) * windSpeed * 0.02;
                    y += Math.sin(angle + Math.PI/2) * windSpeed * 0.02;
                }
                
                // é‡ç½®è¶…å‡ºé‚Šç•Œçš„ç²’å­
                if (Math.abs(x) > 15 || Math.abs(z) > 15) {
                    // æ ¹æ“šé¢¨å‘é‡æ–°ç”Ÿæˆç²’å­
                    if (windVecX > 0) x = -15;
                    else if (windVecX < 0) x = 15;
                    else x = (Math.random() - 0.5) * 30;
                    
                    if (windVecZ > 0) z = -15;
                    else if (windVecZ < 0) z = 15;
                    else z = (Math.random() - 0.5) * 30;
                    
                    y = (Math.random() - 0.5) * 20;
                }
                
                positions[idx] = x;
                positions[idx + 1] = y;
                positions[idx + 2] = z;
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
        
        // çƒé«”ç‰©ç†æ›´æ–°
        function updateBallPhysics() {
            if (isDragging) return; // æ‹–æ‹½æ™‚ä¸è¨ˆç®—ç‰©ç†
            
            const forces = calculateBernoulliEffect();
            const weight = ballMass * Math.abs(gravity);
            
            // è¨ˆç®—å„æ–¹å‘çš„æ·¨åŠ›å’ŒåŠ é€Ÿåº¦
            const netForceY = forces.lift - weight;
            const netForceX = forces.side;
            const netForceZ = forces.front;
            
            const accelerationY = netForceY / ballMass;
            const accelerationX = netForceX / ballMass;
            const accelerationZ = netForceZ / ballMass;
            
            // æ›´æ–°é€Ÿåº¦å’Œä½ç½®
            ballVelocityY += accelerationY * 0.016; // å‡è¨­60fps
            ballVelocityX += accelerationX * 0.016;
            ballVelocityZ += accelerationZ * 0.016;
            
            ball.position.y += ballVelocityY * 0.016;
            ball.position.x += ballVelocityX * 0.016;
            ball.position.z += ballVelocityZ * 0.016;
            
            // æ·»åŠ é˜»å°¼
            ballVelocityY *= 0.98;
            ballVelocityX *= 0.98;
            ballVelocityZ *= 0.98;
            
            // é‚Šç•Œé™åˆ¶
            if (ball.position.y < -7 + ballRadius) {
                ball.position.y = -7 + ballRadius;
                ballVelocityY = 0;
            }
            if (ball.position.y > 8) {
                ball.position.y = 8;
                ballVelocityY = 0;
            }
            
            // Xè»¸é‚Šç•Œ
            if (Math.abs(ball.position.x) > 10) {
                ball.position.x = ball.position.x > 0 ? 10 : -10;
                ballVelocityX = 0;
            }
            
            // Zè»¸é‚Šç•Œ
            if (Math.abs(ball.position.z) > 8) {
                ball.position.z = ball.position.z > 0 ? 8 : -8;
                ballVelocityZ = 0;
            }
            
            // çƒé«”é¡è‰²è®ŠåŒ–è¡¨ç¤ºå‡åŠ›
            if (forces.lift > weight) {
                ball.material.color.setHex(0x00ff00); // ç¶ è‰²è¡¨ç¤ºä¸Šå‡
            } else if (forces.lift > 0) {
                ball.material.color.setHex(0xffff00); // é»ƒè‰²è¡¨ç¤ºå¹³è¡¡
            } else {
                ball.material.color.setHex(0xff6b6b); // ç´…è‰²è¡¨ç¤ºä¸‹é™
            }
        }
        
        // ç›¸æ©Ÿè¨­ç½®
        camera.position.set(8, 2, 8);
        camera.lookAt(0, 0, 0);
        
        // å‹•ç•«å¾ªç’°
        function animate() {
            requestAnimationFrame(animate);
            
            updateParticles();
            updateBallPhysics();
            
            // çƒé«”æ—‹è½‰
            ball.rotation.x += 0.01;
            ball.rotation.z += 0.005;
            
            renderer.render(scene, camera);
        }
        
        // éŸ¿æ‡‰å¼è¨­è¨ˆ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // åˆå§‹åŒ–
        animate();
    </script>
</body>
</html>